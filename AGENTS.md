# Braeburn — Agent Guidelines

## Project Overview

**braeburn** is a macOS system updater CLI tool written in TypeScript. It orchestrates update
steps for Homebrew, Mac App Store, Oh My Zsh, npm, pip, pyenv, nvm, .NET, and macOS itself.
It is a pure Node.js ESM CLI with no frontend framework or bundler.

## Repository Structure

```
src/
  commands/     # One file per CLI sub-command (update, log, config, setup)
  steps/        # One file per update tool (homebrew, npm, pip, …) + shared index.ts
  ui/           # Terminal UI renderers (screen, header, prompt, outputBox, …)
  config.ts     # TOML config read/write and step enable/disable logic
  logger.ts     # Per-step log file creation and lookup
  runner.ts     # Shell command execution wrappers (execa)
  index.ts      # CLI entry point, Commander program setup
dist/           # Compiled JS output (git-ignored, generated by tsc)
```

## Build Commands

```sh
# Compile TypeScript → dist/
npm run build

# Run directly from source (no compile step needed)
npm run dev

# Run compiled output
npm start
```

There is **no test suite**, no linter, and no formatter configured in this project. The only
quality gate is TypeScript's strict compiler.

## TypeScript Configuration

`tsconfig.json` uses `"module": "NodeNext"` / `"moduleResolution": "NodeNext"` with
`"strict": true`. Key implications:

- All relative imports **must use `.js` extensions** even though source files are `.ts`.
- Full strict mode: no implicit `any`, strict null checks, etc.
- Target is `ES2022` — no down-compilation of `async/await` or modern syntax.
- `"declaration": true` emits `.d.ts` files alongside compiled output in `dist/`.

## Import Conventions

```ts
// Node built-ins — always use the node: prefix
import { readFile } from "node:fs/promises"
import { join } from "node:path"

// Relative imports — always include .js extension
import { runShellCommand } from "../runner.js"
import type { Step } from "../steps/index.js"

// Type-only imports — use import type
import type { BraeburnConfig } from "../config.js"
```

- No path aliases (no `@/` or custom mappings in `tsconfig.json`).
- `import type` is used consistently for type-only imports.

## Naming Conventions

| Kind | Convention | Example |
|---|---|---|
| Files | `camelCase.ts` | `outputBox.ts`, `currentStep.ts` |
| Step files | lowercase tool name | `homebrew.ts`, `npm.ts` |
| Variables / functions | `camelCase` | `checkIsAvailable`, `runStep` |
| Module-level constants | `SCREAMING_SNAKE_CASE` | `ALL_STEPS`, `PROTECTED_STEP_IDS` |
| Types / type aliases | `PascalCase` | `Step`, `AppState`, `StepPhase` |
| Step object names | `<tool>Step` | `homebrewStep`, `npmStep` |
| UI builder functions | `buildXxxLines` | `buildHeaderLines`, `buildScreenLines` |
| UI renderer functions | `renderXxx` | `renderScreen` |

- Use `type` keyword exclusively — **no `interface`** anywhere in the codebase.
- Options objects use a `RunXxxCommandOptions` naming pattern.

## Engineering Principles

These principles take priority over convenience or brevity. When in doubt, optimize for the
reader, not the writer.

### Readability First

Readability is the most important property of code. Code is read far more often than it is
written. Every other principle below serves this goal.

### No Boolean Parameters

Boolean parameters obscure the meaning of a call site — a bare `true` or `false` tells the
reader nothing about intent. This applies to positional parameters, boolean fields in options
objects, and boolean values in data structures like `Record<string, boolean>`. Use descriptive
string literal unions instead.

```ts
// Bad — what does `true` mean here?
runStep(step, true)
applyUpdates(config, stepUpdates, true)

// Also bad — boolean field in an options object is still opaque at the call site
type Options = { showLogo: boolean }
runUpdate({ showLogo: true })

// Good — the call site is self-documenting
runStep(step, { mode: "dry-run" })
runUpdate({ logoVisibility: "visible" })
applyUpdates({ config, stepUpdates, logoUpdate: "enable" })
```

### Avoid Side Effects

Functions should do one thing and return a value. Mutating external state, writing to disk, or
emitting output inside a function that is nominally about computation makes behaviour hard to
follow and hard to test. Push side effects to the edges — keep the core logic pure.

```ts
// Bad — computes and writes in one shot
function updateConfig(stepId: string, enabled: boolean) {
  config.steps[stepId] = enabled
  writeFileSync(configPath, serialize(config))
}

// Good — separate concerns
function withStepEnabled(config: BraeburnConfig, stepId: string): BraeburnConfig { ... }
async function saveConfig(config: BraeburnConfig): Promise<void> { ... }
```

### No Code Comments

Code comments are a signal that the code itself is not clear enough. Prefer renaming variables
and functions, extracting well-named helpers, or restructuring logic until the code explains
itself. Comments are only acceptable for non-obvious external constraints (e.g. a workaround
for a known OS bug) and must explain *why*, never *what*.

### Descriptive Variable Names

Names should communicate intent without ambiguity. If a name feels too long it is likely
because the variable is carrying too much responsibility — split it up rather than shortening
the name.

```ts
// Bad
const d = new Date()
const res = await run(s)
const x = steps.filter((s) => s.enabled)

// Good
const updateStartedAt = new Date()
const homebrewUpdateResult = await runHomebrewStep(homebrewStep)
const enabledSteps = steps.filter((step) => step.isEnabled)
```

### Design for Testability

Every meaningful unit of logic should be runnable in isolation. This means:

- Pure functions over stateful classes.
- Dependencies passed in (injection) rather than imported directly.
- Side-effecting operations (file I/O, shell execution) wrapped behind an interface so they can
  be substituted.
- No hidden global state.

Even though there is currently no test suite, new code must be structured so that one could be
added without refactoring the core logic.

## Code Style

### Types

```ts
// Prefer type aliases over interfaces
type Step = {
  id: string
  name: string
  checkIsAvailable: () => Promise<boolean>
  run: (options: RunStepOptions) => Promise<void>
}

// Discriminated union string literals for state
type StepPhase = "pending" | "running" | "complete" | "failed" | "skipped"

// Use as casts sparingly — only for external/untyped data
const config = parsed as BraeburnConfig
```

### Error Handling

```ts
// Empty catch for "return a default" scenarios
try {
  return await readConfig()
} catch {
  return structuredClone(EMPTY_CONFIG)
}

// Extract message from unknown errors
catch (error) {
  const msg = error instanceof Error ? error.message : String(error)
}
```

- Never `throw` from step runners — failures are captured in state.
- `process.exitCode = 1` for soft/non-fatal exits.
- `process.exit(1)` for hard exits where the process must stop immediately.

### Async Patterns

```ts
// All I/O is async/await
const content = await readFile(configPath, "utf8")

// Parallel work with Promise.all
const results = await Promise.all(steps.map((s) => s.checkIsAvailable()))

// Wrap event-based APIs in promises
await new Promise<void>((resolve) => {
  readline.once("keypress", () => resolve())
})
```

- Use `execa` for all shell commands — never `child_process` directly.

### Terminal Output

```ts
// Always use process.stdout.write — never console.log
process.stdout.write(buildScreenLines(state).join("\n"))

// Errors go to stderr
process.stderr.write(`Error: ${message}\n`)

// Use chalk for all colour and styling
chalk.green("success"), chalk.red("error"), chalk.dim("muted")
```

## Architectural Patterns

### Step Interface (Plugin Model)

Each update tool is a self-contained `Step` object in its own file:

```ts
// src/steps/homebrew.ts
const homebrewStep: Step = {
  id: "homebrew",
  name: "Homebrew",
  description: "Update Homebrew and installed packages",
  checkIsAvailable: async () => checkCommandExists("brew"),
  run: async (options) => { /* ... */ },
}

export default homebrewStep
```

Steps are registered in `src/index.ts` by adding them to the steps array. The orchestrator
in `commands/update.ts` is generic and does not reference any specific tool.

### Pure Builder + Imperative Renderer

UI is split into:

- **Pure functions** `buildXxxLines(...): string[]` — return lines with no side effects.
- **Renderer** `renderScreen(content: string)` — erases previous output with ANSI codes and
  writes new content to stdout.

### State Machine

The update command uses an explicit mutable `AppState` with a `currentPhase: StepPhase`
discriminated union. As steps progress, state is mutated and the screen is redrawn.

### Opt-Out Config Model

Config only stores `false` entries for disabled steps. Absent keys mean enabled. New steps are
on by default; the config file stays minimal.
